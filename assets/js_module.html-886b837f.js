import{_ as a,r as t,o as e,c as p,a as n,b as o,d as c,e as l}from"./app-4d1d3ef4.js";const i={},u=l(`<p>什么是模块 :一个模块（<code>module</code>）就是一个文件。一个脚本就是一个模块。模块可以相互加载，并可以使用特殊的指令 <code>export</code> 和 <code>import</code> 来交换功能，从另一个模块调用一个模块的函数</p><h2 id="常见模块实现方案" tabindex="-1"><a class="header-anchor" href="#常见模块实现方案" aria-hidden="true">#</a> 常见模块实现方案</h2><ul><li><code>AMD(Asynchronous module definition)</code> —— 最古老的模块系统之一，最初由 <code>require.js</code> 库实现。</li><li><code>CommonJS</code> —— 为 <code>Node.js</code> 服务器创建的模块系统。</li><li><code>UMD(Universal Module Definition)</code> —— 另外一个模块系统，建议作为通用的模块系统，它与 <code>AMD</code> 和 <code>CommonJS</code> 都兼容。</li></ul><h2 id="浏览器中模块的书写" tabindex="-1"><a class="header-anchor" href="#浏览器中模块的书写" aria-hidden="true">#</a> 浏览器中模块的书写</h2><p>由于模块支持特殊的关键字和功能，因此我们必须通过使用 <code>&lt;script type=&quot;module&quot;&gt;</code> 特性（<code>attribute</code>）来告诉浏览器，此脚本应该被当作模块（<code>module</code>）来对待。 浏览器会自动获取并解析（<code>evaluate</code>）导入的模块（如果需要，还可以分析该模块的导入），然后运行该脚本。模块只通过 <code>http/https</code> 工作，而非本地 如果你尝试通过 <code>file://</code> 协议在本地打开一个网页，你会发现 <code>import/export</code> 指令不起作用</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">doctype</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token keyword">import</span> <span class="token punctuation">{</span>sayHi<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./say.js&#39;</span><span class="token punctuation">;</span>

    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token string">&#39;John&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与“常规”脚本相比，模块有什么不同呢？</p><ul><li>模块<strong>始终</strong>在严格模式下运行</li><li>每个模块都有自己的顶级作用域（<code>top-level scope</code>）。换句话说，一个模块中的顶级作用域变量和函数在其他脚本中是不可见的。</li><li>模块代码仅在第一次导入时被解析</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 如果这个模块被导入到多个文件中，模块仅在第一次被导入时被解析，并创建 admin 对象，然后将其传入到所有的导入。</span>
<span class="token comment">// 📁 1.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>admin<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./admin.js&#39;</span><span class="token punctuation">;</span>

admin<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Pete&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// 📁 2.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>admin<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./admin.js&#39;</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>admin<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Pete</span>

<span class="token comment">// 1.js 和 2.js 引用的是同一个 admin 对象</span>
<span class="token comment">// 在 1.js 中对对象做的更改，在 2.js 中也是可见的</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在一个模块中，顶级 <code>this</code> 是 <code>undefined</code>。将其与非模块脚本进行比较会发现，非模块脚本的顶级 <code>this</code> 是<strong>全局对象</strong></li></ul><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// window</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>模块脚本 <strong>总是</strong> 被延迟的，与 <code>defer</code> 特性 对外部脚本和内联脚本（<code>inline script</code>）的影响相同。下载外部模块脚本 <code>&lt;script type=&quot;module&quot; src=&quot;...&quot;&gt;</code> 不会阻塞 <code>HTML</code> 的处理，它们会与其他资源并行加载。 模块脚本会等到 <code>HTML</code> 文档完全准备就绪（即使它们很小并且比 <code>HTML</code> 加载速度更快），然后才会运行。 在文档中排在前面的脚本先执行。</li></ul><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"> <span class="token comment">// 因为模块是被延迟的（deferred，所以模块脚本会在整个页面加载完成后才运行</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> button<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object：脚本可以“看见”下面的 button</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!--相较于下面这个常规脚本： 常规脚本会立即运行，常规脚本的运行是在在处理页面的其余部分之前进行的--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> button<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// button 为 undefined，脚本看不到下面的元素</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>button<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Button<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="the-import-expression" tabindex="-1"><a class="header-anchor" href="#the-import-expression" aria-hidden="true">#</a> The <code>import()</code> expression</h2><p>Although <code>import()</code> looks like a function call, it’s a <strong>special syntax</strong> that just happens to use parentheses (similar to <code>super()</code>). So we can’t copy import to a variable or use <code>call/apply</code> with it. It’s <strong>not a function</strong>.</p><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> Reference</h2>`,16),d={href:"https://zhuanlan.zhihu.com/p/33843378",target:"_blank",rel:"noopener noreferrer"};function r(k,m){const s=t("ExternalLinkIcon");return e(),p("div",null,[u,n("p",null,[n("a",d,[o("深入理解 ES6 模块机制"),c(s)])])])}const g=a(i,[["render",r],["__file","/home/runner/work/vuepress_blog/vuepress_blog/docs/.vuepress/.temp/pages/js_basic/js_module.html.vue"]]);export{g as default};
