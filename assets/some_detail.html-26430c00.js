import{_ as a,r as o,o as r,c as i,a as e,b as t,d as c,e as n}from"./app-4d1d3ef4.js";const d={},p=n('<h2 id="console-dir-vs-console-log" tabindex="-1"><a class="header-anchor" href="#console-dir-vs-console-log" aria-hidden="true">#</a> <code>console.dir</code> vs <code>console.log</code></h2><p>For JavaScript objects these commands usually do the same.But for <strong>DOM elements</strong> they are different :</p><ul><li><code>console.log(elem)</code> shows the element DOM tree.</li><li><code>console.dir(elem)</code> shows the element as a DOM object, good to explore its properties.</li></ul><h2 id="node-element-tagname" tabindex="-1"><a class="header-anchor" href="#node-element-tagname" aria-hidden="true">#</a> node element tagName</h2><p>The <strong>tag name</strong> is always uppercase except in <strong>XML mode</strong>. The browser has <strong>two modes</strong> of processing documents: HTML and XML. Usually the HTML-mode is used for webpages. XML-mode is enabled when the browser receives an XML-document with the header: <code>Content-Type: application/xml+xhtml</code>.</p><p>In HTML mode <code>tagName/nodeName</code> is always <strong>uppercased</strong>: it’s BODY either for <code>&lt;body&gt;</code> or <code>&lt;BoDy&gt;</code>.</p><p>In XML mode the case is kept “as is”. Nowadays XML mode is <strong>rarely</strong> used.</p><h2 id="the-hidden-property" tabindex="-1"><a class="header-anchor" href="#the-hidden-property" aria-hidden="true">#</a> The “hidden” property</h2><p>The “hidden” attribute and the DOM property specifies whether the element is visible or not. Technically, hidden works the same as <code>style=&quot;display:none&quot;</code>. But it’s shorter to write.</p>',9),l={id:"html-attributes",tabindex:"-1"},u=e("a",{class:"header-anchor",href:"#html-attributes","aria-hidden":"true"},"#",-1),h={href:"https://javascript.info/dom-attributes-and-properties#html-attributes",target:"_blank",rel:"noopener noreferrer"},m=n(`<p>In HTML, tags may have attributes. When the browser parses the HTML to create DOM objects for tags, it recognizes <strong>standard attributes</strong> and creates DOM properties from them.</p><p>So when an element has <code>id</code> or another standard attribute, the corresponding property gets created. But that doesn’t happen if the attribute is non-standard.</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>test<span class="token punctuation">&quot;</span></span> <span class="token attr-name">something</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>non-standard<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token function">alert</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// test</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>something<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>So, if an attribute is non-standard, there <strong>won’t be a DOM-property</strong> for it.</p><p>Standard attributes are described in the specification for the corresponding element class.</p><p>HTML attributes have the following features:</p><ul><li>Their name is <strong>case-insensitive</strong> (id is same as ID).</li><li>Their values are always <strong>strings</strong></li></ul><h2 id="property-attribute-synchronization" tabindex="-1"><a class="header-anchor" href="#property-attribute-synchronization" aria-hidden="true">#</a> Property-attribute synchronization</h2><p>When a standard attribute changes, the corresponding property is <strong>auto-updated</strong>, and (with some exceptions). In the example below id is modified as an attribute, and we can see the property changed too. And then the same backwards.</p><p>But there are <strong>exclusions</strong>, for instance <code>input.value</code> synchronizes only from <strong>attribute → to property</strong>, but not back</p><h2 id="html-dataset" tabindex="-1"><a class="header-anchor" href="#html-dataset" aria-hidden="true">#</a> html dataset</h2><p>All attributes starting with <code>“data-”</code> are reserved for programmers’ use. They are available in the <code>dataset</code> property.Please note that we can not only read, but also modify data-attributes.</p><p>For instance, if an elem has an attribute named <code>data-about</code>, it’s available as <code>elem.dataset.about</code></p><p>Multiword attributes like <code>data-order-state</code> become camel-cased: <code>dataset.orderState</code>.</p><h2 id="prefixed-properties" tabindex="-1"><a class="header-anchor" href="#prefixed-properties" aria-hidden="true">#</a> Prefixed properties</h2><p>Browser-prefixed properties like <code>-moz-border-radius</code>, <code>-webkit-border-radius</code> also follow the same rule: <strong>a dash means upper case</strong>.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>button<span class="token punctuation">.</span>style<span class="token punctuation">.</span>MozBorderRadius <span class="token operator">=</span> <span class="token string">&#39;5px&#39;</span><span class="token punctuation">;</span>
button<span class="token punctuation">.</span>style<span class="token punctuation">.</span>WebkitBorderRadius <span class="token operator">=</span> <span class="token string">&#39;5px&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="resetting-the-style-property" tabindex="-1"><a class="header-anchor" href="#resetting-the-style-property" aria-hidden="true">#</a> Resetting the style property</h2><p>Sometimes we want to assign a style property, and later remove it. For instance, to hide an element, we can set <code>elem.style.display = &quot;none&quot;</code>. Then later we may want to remove the <code>style.display</code> as if it were not set. Instead of delete <code>elem.style.display</code> we should assign an empty string to it: <code>elem.style.display = &quot;&quot;</code>. If we set <code>style.display</code> to an empty string, then the browser applies CSS classes and its built-in styles normally, as if there were no such <code>style.display</code> property at all.</p><h2 id="width-height-of-the-document" tabindex="-1"><a class="header-anchor" href="#width-height-of-the-document" aria-hidden="true">#</a> Width/height of the document</h2><p>Theoretically, as the root document element is <code>document.documentElement</code>, and it encloses all the content, we could measure the document’s full size as <code>document.documentElement.scrollWidth/scrollHeight</code>.</p><p>But on that element, for the whole page, these properties do not work as intended. In Chrome/Safari/Opera, if there’s no scroll, then <code>documentElement.scrollHeight</code> may be even <strong>less than</strong> <code>documentElement.clientHeight</code>! Weird, right?</p><p>To reliably obtain the full document height, we should take the maximum of these properties:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> scrollHeight <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollHeight<span class="token punctuation">,</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollHeight<span class="token punctuation">,</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">,</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">,</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientHeight<span class="token punctuation">,</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>DOM elements have their current scroll state in their <code>scrollLeft/scrollTop</code> properties.</p><p>For <code>document</code> scroll, <code>document.documentElement.scrollLeft/scrollTop</code> works in most browsers, except older WebKit-based ones, like Safari (bug 5991), where we should use <code>document.body</code> instead of <code>document.documentElement</code>.</p><p>Luckily, we don’t have to remember these peculiarities at all, because the scroll is available in the special properties, <code>window.pageXOffset/pageYOffset</code>,Also available as window properties <code>scrollX</code> and <code>scrollY</code></p><ul><li><code>window.pageXOffset</code> is an alias of <code>window.scrollX</code>.</li><li><code>window.pageYOffset</code> is an alias of <code>window.scrollY</code>.</li></ul><h2 id="elementfrompoint-x-y" tabindex="-1"><a class="header-anchor" href="#elementfrompoint-x-y" aria-hidden="true">#</a> <code>elementFromPoint(x, y)</code></h2><p>The call to <code>document.elementFromPoint(x, y)</code> returns the most nested element at <strong>window coordinates (x, y)</strong>, For out-of-window coordinates the <code>elementFromPoint</code> returns <code>null</code></p>`,30);function g(b,k){const s=o("ExternalLinkIcon");return r(),i("div",null,[p,e("h2",l,[u,t(),e("a",h,[t("HTML attributes"),c(s)])]),m])}const y=a(d,[["render",g],["__file","/home/runner/work/vuepress_blog/vuepress_blog/docs/.vuepress/.temp/pages/js_basic/some_detail.html.vue"]]);export{y as default};
